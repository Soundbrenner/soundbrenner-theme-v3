<!doctype html>
{% liquid
  assign sb_theme_mode = 'dark'
  assign sb_theme_locked = false
  if request.page_type == 'collection' and collection != blank
    assign collection_settings_ref = collection.metafields.custom.collection_settings.value | default: collection.metafields.custom.collection_settings
    if collection_settings_ref != blank
      assign collection_light_theme = collection_settings_ref.light_theme.value | default: collection_settings_ref.light_theme
      if collection_light_theme == true or collection_light_theme == 'true' or collection_light_theme == 1 or collection_light_theme == '1'
        assign sb_theme_mode = 'light'
        assign sb_theme_locked = true
      endif
    endif
  elsif request.page_type == 'product' and product != blank
    assign product_settings_ref = product.metafields.custom.sbv2_product_settings.value | default: product.metafields.custom.sbv2_product_settings
    if product_settings_ref != blank
      assign product_light_theme = product_settings_ref.light_theme.value | default: product_settings_ref.light_theme
      if product_light_theme == true or product_light_theme == 'true' or product_light_theme == 1 or product_light_theme == '1'
        assign sb_theme_mode = 'light'
        assign sb_theme_locked = true
      endif
    endif
  endif
%}
<html
  lang="{{ request.locale.iso_code }}"
  data-theme="{{ sb_theme_mode }}"
  {% if sb_theme_locked %}
    data-theme-locked="light"
  {% endif %}
>
  <head>
    {% # Inlined CSS Variables %}
    {% render 'css-variables' %}

    {% assign sb_primary_font_regular = settings.type_primary_font %}
    {% assign sb_primary_font_semibold = settings.type_primary_font | font_modify: 'weight', '600' %}
    {% assign sb_primary_font_bold = settings.type_primary_font | font_modify: 'weight', 'bold' %}
    {% assign sb_display_font_bold = settings.type_display_font | font_modify: 'weight', 'bold' %}

    {% comment %}
      Font preloading:
      1. Preconnect to font CDN for faster connection
      2. Preload critical above-the-fold variants
      3. Additional variants load on-demand via @font-face
    {% endcomment %}
    {% if settings.type_primary_font.system? == false or settings.type_display_font.system? == false %}
      <link rel="preconnect" href="https://fonts.shopifycdn.com" crossorigin>
    {% endif %}
    {% unless settings.type_primary_font.system? %}
      {{ sb_primary_font_regular | font_url | preload_tag: as: 'font', crossorigin: 'anonymous' }}
      {{ sb_primary_font_semibold | font_url | preload_tag: as: 'font', crossorigin: 'anonymous' }}
      {{ sb_primary_font_bold | font_url | preload_tag: as: 'font', crossorigin: 'anonymous' }}
    {% endunless %}
    {% unless settings.type_display_font.system? %}
      {{ sb_display_font_bold | font_url | preload_tag: as: 'font', crossorigin: 'anonymous' }}
    {% endunless %}

    {% # Load and preload the critical CSS %}
    {{ 'critical.css' | asset_url | stylesheet_tag: preload: true }}

    {% # Social, title, etc. %}
    {% render 'meta-tags' %}

    {{ content_for_header }}
  </head>

  <body>
    {% sections 'header-group' %}

    {{ content_for_layout }}

    {% sections 'footer-group' %}

    <script>
      (() => {
        const revealGroups = document.querySelectorAll('[data-sb-reveal]');
        if (!revealGroups.length) return;

        if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
          revealGroups.forEach((group) => group.classList.add('is-inview'));
          return;
        }

        if (!('IntersectionObserver' in window)) {
          revealGroups.forEach((group) => group.classList.add('is-inview'));
          return;
        }

        const observer = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              if (!entry.isIntersecting && entry.intersectionRatio <= 0) return;
              entry.target.classList.add('is-inview');
              observer.unobserve(entry.target);
            });
          },
          {
            threshold: 0,
            rootMargin: '0px',
          }
        );

        revealGroups.forEach((group) => {
          group.classList.add('sb-reveal--animate');

          const rect = group.getBoundingClientRect();
          const inInitialView = rect.top < window.innerHeight && rect.bottom > 0;

          if (inInitialView) {
            // Ensure above-the-fold items animate after initial paint.
            window.requestAnimationFrame(() => {
              window.requestAnimationFrame(() => {
                group.classList.add('is-inview');
              });
            });
            return;
          }

          observer.observe(group);
        });
      })();
    </script>
    <script>
      (() => {
        const rootSelector = '#klaviyo-reviews-all';
        const countPattern = /\b(\d{4,})(?=\s+reviews\b)/g;
        const klaviyoStarPath =
          'M3.825 19.5L5.45 12.475L0 7.75L7.2 7.125L10 0.5L12.8 7.125L20 7.75L14.55 12.475L16.175 19.5L10 15.775L3.825 19.5Z';
        const numberFormatter = new Intl.NumberFormat(document.documentElement.lang || undefined);
        let formattingObserver = null;
        let widgetObserver = null;

        const applyCustomStarPaths = (scope = document) => {
          const stars = scope.querySelectorAll('path.kl_reviews__star');
          stars.forEach((star) => {
            if (star.getAttribute('d') === klaviyoStarPath) return;
            star.setAttribute('d', klaviyoStarPath);
          });
        };

        const formatStarRatingWidgets = (scope = document) => {
          const buttons = scope.querySelectorAll('.klaviyo-star-rating-widget .kl_reviews__star_rating_widget');
          buttons.forEach((button) => {
            const aria = button.getAttribute('aria-label') || '';
            const ratingMatch = aria.match(/([\d.,]+)\s*stars?/i);
            const countFromAria = aria.match(/(\d[\d,]*)\s*(ratings?|reviews?)/i);
            if (!ratingMatch) return;

            const starsBadge = button.querySelector('.kl_reviews__stars_badge');
            if (!starsBadge) return;

            const existingLabel = button.querySelector('.kl_reviews__star_rating_widget__label');
            const countFromLabel = (existingLabel?.textContent || '').match(/(\d[\d,]*)/);
            const rawCount = (countFromAria && countFromAria[1]) || (countFromLabel && countFromLabel[1]) || '0';
            const countNumber = Number(String(rawCount).replace(/,/g, ''));
            const formattedCount = Number.isFinite(countNumber) ? numberFormatter.format(countNumber) : rawCount;
            const ratingNumber = Number(String(ratingMatch[1]).replace(',', '.'));
            const formattedRating = Number.isFinite(ratingNumber) ? ratingNumber.toFixed(1) : ratingMatch[1];

            const copy = `${formattedRating} (by ${formattedCount} musicians)`;

            let label = button.querySelector('.sb-klaviyo-average-rating');
            if (!label) {
              label = document.createElement('span');
              label.className = 'sb-klaviyo-average-rating';
              starsBadge.insertAdjacentElement('afterend', label);
            }
            if (label.textContent !== copy) {
              label.textContent = copy;
            }

            if (existingLabel && existingLabel.style.display !== 'none') {
              existingLabel.style.display = 'none';
            }
          });
        };

        const formatCounts = (root) => {
          const targets = root.querySelectorAll('.kl_reviews__summary__stars__count');

          targets.forEach((target) => {
            const currentText = target.textContent;
            if (!currentText) return;

            const nextText = currentText.replace(countPattern, (_, digits) =>
              numberFormatter.format(Number(digits))
            );

            if (nextText !== currentText) {
              target.textContent = nextText;
            }
          });

          const orderTimestamps = root.querySelectorAll('.kl_reviews__review__order_timestamp');
          orderTimestamps.forEach((target) => {
            const currentText = target.textContent;
            if (!currentText) return;

            const withoutBullet = currentText.replace(/^\s*[•·]\s*/, '').trim();
            const deduped = withoutBullet.replace(/^(.+?)\1+$/, '$1').trim();

            if (deduped !== currentText.trim()) {
              target.textContent = deduped;
              return;
            }

            if (withoutBullet !== currentText.trim()) {
              target.textContent = withoutBullet;
              return;
            }

            if (deduped !== withoutBullet) {
              target.textContent = deduped;
              return;
            }

            if (deduped !== currentText) {
              target.textContent = deduped;
            }
          });

          const productReviewInfos = root.querySelectorAll(
            '.kl_reviews__review__product_card__details__review_info'
          );
          productReviewInfos.forEach((target) => {
            const currentText = target.textContent;
            if (!currentText) return;

            const nextText = currentText
              .replace(/\s+/g, ' ')
              .replace(/\s·\s/g, ' • ')
              .trim();

            const ratingMatch = nextText.match(/(\d+(?:[.,]\d+)?)/);
            const reviewsMatch = nextText.match(/(\d[\d,]*)\s+reviews\b/i);

            if (ratingMatch && reviewsMatch) {
              const ratingValue = ratingMatch[1];
              const reviewsValue = reviewsMatch[1];
              const nextHtml =
                `<span class="sb-klaviyo-rating-value">${ratingValue}</span>` +
                `<span class="sb-klaviyo-inline-star" aria-hidden="true"></span>` +
                `<span class="sb-klaviyo-inline-dot" aria-hidden="true">•</span>` +
                `<span class="sb-klaviyo-rating-reviews">${reviewsValue} reviews</span>`;
              if (target.innerHTML !== nextHtml) target.innerHTML = nextHtml;
              return;
            }

            // Fallback dedupe for any repeated fragments during rerenders.
            const dedupedText = nextText.replace(/(.+?)\s+\1+$/, '$1').trim();
            if (dedupedText !== currentText.trim()) target.textContent = dedupedText;
          });

          const productNames = root.querySelectorAll('.kl_reviews__review__product_card__details__name');
          productNames.forEach((target) => {
            const currentText = target.textContent;
            if (!currentText) return;
            const compact = currentText.replace(/\s+/g, ' ').trim();
            const deduped = compact.replace(/^(.+?)\s+\1+$/, '$1').trim();
            if (deduped !== compact) target.textContent = deduped;
          });

          applyCustomStarPaths(root);
        };

        const observeAndFormat = (root) => {
          if (formattingObserver) return;

          formatCounts(root);

          let isQueued = false;
          formattingObserver = new MutationObserver(() => {
            if (isQueued) return;
            isQueued = true;
            requestAnimationFrame(() => {
              isQueued = false;
              formatCounts(root);
            });
          });

          formattingObserver.observe(root, { childList: true, subtree: true });
        };

        const observeWidgets = () => {
          if (widgetObserver) return;

          applyCustomStarPaths(document);
          formatStarRatingWidgets(document);

          let isQueued = false;
          widgetObserver = new MutationObserver(() => {
            if (isQueued) return;
            isQueued = true;
            requestAnimationFrame(() => {
              isQueued = false;
              applyCustomStarPaths(document);
              formatStarRatingWidgets(document);
            });
          });

          widgetObserver.observe(document.body, { childList: true, subtree: true });
        };

        const init = () => {
          const root = document.querySelector(rootSelector);
          if (!root) return false;
          observeAndFormat(root);
          return true;
        };

        observeWidgets();
        if (init()) return;

        const rootFinder = new MutationObserver(() => {
          if (!init()) return;
          rootFinder.disconnect();
        });

        rootFinder.observe(document.body, {
          childList: true,
          subtree: true,
        });
      })();
    </script>
  </body>
</html>
